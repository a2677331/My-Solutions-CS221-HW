Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 1
c:STRINGS.asm



      1				     DOSSEG
      2	0000			     .MODEL  large
      3
      4	0000			     .STACK  200h
      5
      6
      7	0000			     .DATA
      8	      =0000		     ASCNull	     EQU     0	     ; ASCII null
      9	      =000D		     ASCcr	     EQU     13	     ; ASCII carriage return
     10	      =000A		     ASClf	     EQU     10	     ; ASCII line feed
     11	      =00FF		     BuffSize	     EQU     255     ; Maximum string size
     12	      =0080		     MaxL	     EQU     128     ; 128 character string
     13
     14	0000  00		     exCode	     db	     0
     15	0001  57 65 6C 63 6F 6D	65+  welcome	     db	     "Welcome to echo-string",ASCcr,ASClf
     16	      20 74 6F 20 65 63	68+
     17	      6F 2D 73 74 72 69	6E+
     18	      67 0D 0A
     19	0019  54 79 70 65 20 61	6E+	     db	     "Type any string and press	Enter",ASCcr,ASClf,ASClf,0
     20	      79 20 73 74 72 69	6E+
     21	      67 20 61 6E 64 20	70+
     22	      72 65 73 73 20 45	6E+
     23	      74 65 72 0D 0A 0A	00
     24	003C  80*(00) 00	     testString	     db	     MaxL  dup (0),0	; max length plus null character
     25
     26	00BD  31 32 33 34 35 36	37+  v1		     db	     '12345678901234567890',0  ; 20 byte string
     27	      38 39 30 31 32 33	34+
     28	      35 36 37 38 39 30	00
     29	00D2  28*(00)		     v2		     db	     40	dup (0)		       ; 40 byte string
     30
     31	00FA  51*(FF)		     buff	     db	     81	dup(0FFh)
     32
     33	014B  53 61 6D 70 6C 65	20+  str1	     db	     'Sample user response string',0
     34	      75 73 65 72 20 72	65+
     35	      73 70 6F 6E 73 65	20+
     36	      73 74 72 69 6E 67	00
     37	0167  53 74 72 69 6E 67	20+  str2	     db	     'String was empty$'
     38	      77 61 73 20 65 6D	70+
     39	      74 79 24
     40
     41	0178  61 62 63 64 65 66	67+  lc		     db	     'abcdefghijklmnopqrstuvwxz',0
     42	      68 69 6A 6B 6C 6D	6E+
     43	      6F 70 71 72 73 74	75+
     44	      76 77 78 7A 00
     45
     46	0192  4C 69 6F 6E 73 20	61+  str3	     db	     'Lions and	tigers and bears, oh my!',0
     47	      6E 64 20 74 69 67	65+
     48	      72 73 20 61 6E 64	20+
     49	      62 65 61 72 73 2C	20+
     50	      6F 68 20 6D 79 21	00
     51
     52	01B5  49 6E 73 65 72 74	20+  dest	     db	     'Insert into slot-B	       ',0
     53	      69 6E 74 6F 20 73	6C+
     54	      6F 74 2D 42 20 20	20+
     55	      20 20 20 20 20 20	20+
     56	      20 20 20 20 20 00
     57				     ;
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 2
c:STRINGS.asm



     58				     ; extra space for dest to expand into
     59				     ;
     60	01D7  28*(00)			     db	     40	dup (0)
     61
     62	01FF  74 61 62 2D 41 20	00   source	     db	     'tab-A ',0
     63
     64	0206  74 68 65 20 65 6E	64+  source1	     db	     'the end!',0
     65	      21 00
     66	020F  54 68 69 73 20 69	73+  dest1	     db	     'This is ',0
     67	      20 00
     68				     ;
     69				     ; extra space for concatanation
     70				     ;
     71	0218  0F*(00)			     db	     15	dup (0)
     72
     73	0227  4F 72 69 67 69 6E	61+  str4	     db	     'Original string',0
     74	      6C 20 73 74 72 69	6E+
     75	      67 00
     76	0237  50*(??)		     str5	     db	     80	dup (?)
     77
     78	0287  2E 41 53 4D 00	     ext	     db	     '.ASM',0
     79	028C  4D 59 54 45 53 54	2E+  filename	     db	     'MYTEST.ASM',0
     80	      41 53 4D 00
     81	0297  49 20 66 6F 75 6E	64+  eureka	     db	     'I	found it!!$'
     82	      20 69 74 21 21 24
     83
     84	02A4  28 38 30 30 29 2D	35+  phoneNumber     db	     '(800)-555-1212',0
     85	      35 35 2D 31 32 31	32+
     86	      00
     87	02B3  28 38 30 30 29 2D	00   areaCode	     db	     '(800)-',0
     88
     89				     ;
     90				     ; define a	data strucure
     91				     ;
     92	*2BA			     StrBuffer struc
     93	*000  01*(FF)		     maxLen  db	     BuffSize ;	max buffer length
     94	*001  01*(00)		     strLen  db	     0	     ; string length
     95	*002  01*(FF*(??))	     chars   db	     BuffSize dup(?)  ;	buffer for StrRead
     96	*101			     StrBuffer ends
     97
     98	02BA  FF 00 FF*(??)	     buffer  StrBuffer	     <>	     ; bufffer variable	for ReadStr
     99
    100
    101				     ;------------------------------------------------
    102				     ; Procedures defined in this file
    103				     ;
    104				     ;	     MoveLeft	     --- memory	move with increasing indexes
    105				     ;	     MoveRight	     --- memory	move with decreasing indexes
    106				     ;	     StrNull	     --- erase all chars in string
    107				     ;	     StrLength	     --- return	number of chars	in string
    108				     ;	     StrUpper	     --- convert chars in string to uppercase
    109				     ;	     StrCompare	     --- alphabetically	compare	two strings
    110				     ;	     StrDelete	     --- delete	chars from stirng
    111				     ;	     StrInsert	     --- insert	chars into strings
    112				     ;	     StrConcat	     --- attach	one string to another
    113				     ;	     StrPos	     --- find position of substring in a string
    114				     ;	     StrRemove	     --- remove	substring from a string
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 3
c:STRINGS.asm



    115				     ;	     StrRead	     --- read string with editing keys
    116				     ;-------------------------------------------------------------
    117	03BB			     .CODE
    118	0000			     ProgramStart:
    119	0000  B8 0000s		     mov   ax,@data
    120	0003  8E D8		     mov   ds,ax     ; set up ds and es	to point to same segment
    121	0005  8E C0		     mov   es,ax
    122
    123	0007  BF 0001r		     mov   di,offset welcome ; display welcome message
    124	000A  E8 01EE		     call  StrWrite
    125
    126	000D  BF 003Cr		     mov   di,offset testString	; address of testString
    127	0010  B9 0080		     mov   cx,MaxL	      ;	cx = maximum length
    128	0013  E8 01BC		     call  StrRead;	     ; read a string from the keyboard
    129	0016  E8 01F5		     call  NewLine;	     ; start a new display line
    130	0019  E8 01DF		     call  StrWrite	     ; echo string to display
    131
    132	001C  BE 00BDr		     mov     si,offset v1    ; assign source address of	v1
    133	001F  BF 00D2r		     mov     di,offset v2    ; assign source address of	v2
    134	0022  BB 0000		     mov     bx,0	     ; set source index(v1[0])
    135	0025  BA 000A		     mov     dx,10	     ; set destination index (v2[10])
    136	0028  B9 0014		     mov     cx,20	     ; specify the number of bytes to move
    137	002B  E8 0075		     call    MoveLeft	     ; move bytes from v1[0] to	v2[10]
    138
    139	002E  BF 00FAr		     mov     di,offset buff  ; address of buf storage area
    140	0031  E8 0095		     call    StrNull	     ; turn it into a null string
    141
    142	0034  BF 014Br		     mov     di,offset str1	   ; address of	string #1
    143	0037  E8 0093		     call    StrLength	     ; set cx to string	length
    144	003A  0B C9		     or	     cx,cx	     ; is cx=0?
    145	003C  74 03		     jz	     lbl1
    146	003E  EB 0B 90		     jmp     lbl2
    147	0041  B4 09		     lbl1:   mov     ah,9	    ; print empty string message
    148	0043  BA 0167r		     mov     dx,offset str2
    149	0046  CD 21		     int     21h
    150	0048  E8 01C3		     call    NewLine
    151	004B			     lbl2:
    152	004B  BF 0178r		     mov     di,offset lc  ; address of	string lc
    153	004E  E8 008C		     call    StrUpper	   ; convert all chars to upper
    154
    155	0051  BF 0192r		     mov     di,offset str3 ; address of lions string
    156	0054  BA 0006		     mov     dx,6	    ; index to 'a' in 'and'
    157	0057  B9 000B		     mov     cx,11	    ; set up to	delete 11 chars
    158	005A  E8 00AF		     call    StrDelete
    159
    160	005D  BE 01FFr		     mov     si,offset source	     ; address of source string
    161	0060  BF 01B5r		     mov     di, offset	dest	     ; address of destination string
    162	0063  BA 0007		     mov     dx,7		; dx= index of 'i' of 'into' in	dest str
    163	0066  E8 00C7		     call    StrInsert		; insert string
    164
    165	0069  BE 0206r		     mov     si,offset source1	     ; address of source string
    166	006C  BF 020Fr		     mov     di,offset dest1	     ; address of destination string
    167	006F  E8 00E8		     call    StrConcat		     ; concatinate
    168
    169	0072  BE 0227r		     mov     si,offset str4	     ; address of string str4
    170	0075  BF 0237r		     mov     di, offset	str5	     ; address of string str5
    171	0078  E8 00F8		     call    StrCopy		     ; copy string
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 4
c:STRINGS.asm



    172
    173	007B  BE 0287r		     mov     si,offset ext	     ; address of the file extension string
    174	007E  BF 028Cr		     mov     di,offset filename	     ; address of the file name	string
    175	0081  E8 0105		     call    StrPos		     ; find the	sring position
    176	0084  74 03		     jz	     fdext		     ; found extension
    177	0086  EB 0E 90		     jmp     notfdext		     ; did not find extension
    178
    179	0089  E8 0182		     fdext:  call    NewLine		     ; end the line of display output
    180	008C  B4 09		     mov     ah,9		     ; print the found it message
    181	008E  BA 0297r		     mov     dx, offset	eureka
    182	0091  CD 21		     int     21h
    183	0093  E8 0178		     call    NewLine
    184
    185
    186	0096			     notfdext:
    187	0096  BE 02B3r		     mov     si,offset areaCode	   ; address of	the area code string
    188	0099  BF 02A4r		     mov     di,offset phoneNumber ; address of	the phone number string
    189	009C  E8 011D		     call    StrRemove		   ; remove the	substring
    190
    191
    192	009F  B4 4C		     mov   ah,4ch		 ;DOS terminate	program	function
    193	00A1  CD 21		     int   21h
    194
    195				     ;------------------------------------------------------
    196				     ; MoveLeft	procedure
    197				     ;
    198				     ;Input:
    199				     ;	     si=address	of source string (s1)
    200				     ;	     di=address	of destination string (s2)
    201				     ;	     bx= index s1 (i1)
    202				     ;	     dx	= index	s2 (i2)
    203				     ;	     cx	= number of bytes to move (count)
    204				     ;
    205				     ;Output:
    206				     ;	     count bytes from s1(i1) moved to the location starting at s2(i2)
    207				     ;
    208				     ;Registers:
    209				     ;	     none
    210				     ;
    211				     ;--------------------------------------------------------
    212	00A3			     MoveLeft	     proc	     near
    213
    214	00A3  E3 0D			     jcxz    @@99    ; exit if count =0
    215
    216	00A5  51			     push    cx	     ;save modified registers
    217	00A6  56			     push    si
    218	00A7  57			     push    di
    219
    220	00A8  03 F3			     add     si,bx   ; index into source string
    221	00AA  03 FA			     add     di,dx   ; index into destination string
    222	00AC  FC			     cld	     ; auto increment on
    223	00AD  F3> A4			     rep     movsb   ;move while cx!=0
    224
    225	00AF  5F			     pop     di	     ;restore registers
    226	00B0  5E			     pop     si
    227	00B1  59			     pop     cx
    228	00B2			     @@99:
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 5
c:STRINGS.asm



    229	00B2  C3			     ret     ; return to calling program
    230	00B3			     MoveLeft	     endp
    231
    232				     ;------------------------------------------------------
    233				     ; MoveRight procedure
    234				     ;
    235				     ;Input:
    236				     ;	     si=address	of source string (s1)
    237				     ;	     di=address	of destination string (s2)
    238				     ;	     bx= index s1 (i1)
    239				     ;	     dx	= index	s2 (i2)
    240				     ;	     cx	= number of bytes to move (count)
    241				     ;
    242				     ;Output:
    243				     ;	     count bytes from s1(i1) moved to the location starting at s2(i2)
    244				     ;
    245				     ;Registers:
    246				     ;	     none
    247				     ;
    248				     ;--------------------------------------------------------
    249	00B3			     MoveRight	     proc	     near
    250
    251	00B3  E3 13			     jcxz    @@98    ; exit if count =0
    252
    253	00B5  51			     push    cx	     ;save modified registers
    254	00B6  57			     push    di
    255	00B7  56			     push    si
    256
    257	00B8  03 F3			     add     si,bx   ; index into source string
    258	00BA  03 FA			     add     di,dx   ; index into destination string
    259	00BC  03 F1			     add     si,cx   ; adjust to last source byte
    260	00BE  4E			     dec     si
    261	00BF  03 F9			     add     di,cx   ; adjust to last destination byte
    262	00C1  4F			     dec     di
    263
    264	00C2  FD			     std	     ; auto decrement on
    265	00C3  F3> A4			     rep     movsb   ;move while cx!=0
    266
    267	00C5  5E			     pop     si	     ;restore registers
    268	00C6  5F			     pop     di
    269	00C7  59			     pop     cx
    270	00C8			     @@98:
    271	00C8  C3			     ret     ; return to calling program
    272	00C9			     MoveRight	     endp
    273
    274				     ;------------------------------------------------------
    275				     ; StrNull procedure
    276				     ;
    277				     ;Input:
    278				     ;	     di=address	of string (s)
    279				     ;
    280				     ;Output:
    281				     ;	     s(0) <- null character (ASCII 0)
    282				     ;
    283				     ;Registers:
    284				     ;	     none
    285				     ;
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 6
c:STRINGS.asm



    286				     ;--------------------------------------------------------
    287	00C9			     StrNull	    proc	    near
    288
    289	00C9  C6 05 00			    mov	     byte ptr[di],ASCNull; insert null at s(0)
    290
    291	00CC  C3			    ret	    ; return to	calling	program
    292	00CD			     StrNull	    endp
    293
    294
    295				     ;------------------------------------------------------
    296				     ; StrLength procedure
    297				     ;
    298				     ;Input:
    299				     ;	     di=address	of string (s)
    300				     ;
    301				     ;Output:
    302				     ;	     cx	= number of non-null characters	in s
    303				     ;
    304				     ;Registers:
    305				     ;	     cx
    306				     ;
    307				     ;--------------------------------------------------------
    308	00CD			     StrLength	      proc	      near
    309
    310	00CD  50			      push   ax	     ; save modified registers
    311	00CE  57			      push   di
    312
    313	00CF  32 C0			      xor    al,al   ; al <- search character (null)
    314
    315	00D1  B9 FFFF			      mov    cx,0ffffh	     ; max search depth
    316	00D4  FC			      cld		     ; auto increment on
    317	00D5  F2> AE			      repnz  scasb	     ; scan for	al
    318								     ; while [di]!= null & cx != 0
    319	00D7  F7 D1			      not    cx		     ; ones complement of cx
    320	00D9  49			      dec    cx		     ; minus 1 equals length of	string
    321
    322	00DA  5F			      pop    di	     ; restore registers
    323	00DB  58			      pop    ax
    324
    325	00DC  C3			      ret     ;	return to calling program
    326	00DD			     StrLength	      endp
    327
    328				     ;------------------------------------------------------
    329				     ; StrUpper	procedure
    330				     ;
    331				     ;Input:
    332				     ;	     di=address	of string (s)
    333				     ;
    334				     ;Output:
    335				     ;	     lowercase chars in	string converted to uppercase
    336				     ;
    337				     ;Registers:
    338				     ;	     none
    339				     ;
    340				     ;--------------------------------------------------------
    341	00DD			     StrUpper	     proc	     near
    342
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 7
c:STRINGS.asm



    343	00DD  50			      push   ax	     ; save modified registers
    344	00DE  51			      push   cx
    345	00DF  57			      push   di
    346	00E0  56			      push   si
    347
    348	00E1  E8 FFE9			      call StrLength ; set cx =	length of string
    349	00E4  E3 11			      jcxz   @@97    ; exit if length =0
    350	00E6  FC			      cld	     ; auto increment on
    351
    352	00E7  8B F7			      mov    si,di   ; set si=di
    353
    354	00E9			     @@10:
    355	00E9  AC			     lodsb	     ; al <-s[si]; si<-si+1
    356	00EA  3C 61			     cmp     al,'a'  ; is al >=	'a'?
    357	00EC  72 06			     jb	     @@20    ; no, jump	to continue scan
    358	00EE  3C 7A			     cmp     al,'z'  ; is al <='z'?
    359	00F0  77 02			     ja	     @@20    ; no, jump	to continue scan
    360
    361	00F2  2C 20			     sub     al,'a'-'A'	     ; convert lowercase to uppercase
    362	00F4			     @@20:
    363	00F4  AA			     stosb	     ; s[di]<-al; di<-di+1
    364	00F5  E2 F2			     loop    @@10    ;cx<-cx-1;	loop if	cx>0
    365
    366	00F7			     @@97:
    367	00F7  5E			     pop     si
    368	00F8  5F			     pop     di	     ; restore registers
    369	00F9  59			     pop     cx
    370	00FA  58			     pop     ax
    371
    372	00FB  C3			     ret     ; return to calling program
    373	00FC			     StrUpper	     endp
    374
    375				     ;------------------------------------------------------
    376				     ; StrCompare procedure
    377				     ;
    378				     ;Input:
    379				     ;	     si=address	of string 1 (s1)
    380				     ;	     di=address	of string 2 (s2)
    381				     ;
    382				     ;Output:
    383				     ;	     flags set for conditional jump using jb, jbe, je, ja, or jae
    384				     ;
    385				     ;Registers:
    386				     ;	     none
    387				     ;
    388				     ;--------------------------------------------------------
    389	00FC			     StrCompare	       proc	       near
    390
    391	00FC  50			      push   ax	     ; save modified registers
    392	00FD  57			      push   di
    393	00FE  56			      push   si
    394
    395	00FF  FC			      cld	     ; auto increment on
    396
    397	0100			     @@11:
    398	0100  AC			     lodsb	     ; al <-s[si]; si<-si+1
    399	0101  AE			     scasb	     ; compare al and [di]; di<-di+1
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 8
c:STRINGS.asm



    400	0102  75 04			     jne     @@21    ; exit if nonequal	chars found
    401	0104  0A C0			     or	     al,al   ; is al = 0? i.e. at the end of string 1
    402	0106  75 F8			     jne     @@11    ; if no jump, else	exit
    403
    404	0108			     @@21:
    405	0108  5E			     pop     si
    406	0109  5F			     pop     di	     ; restore registers
    407	010A  58			     pop     ax
    408
    409	010B  C3			     ret     ; return to calling program
    410	010C			     StrCompare	     endp
    411
    412				     ;------------------------------------------------------
    413				     ; StrDelete procedure
    414				     ;
    415				     ;Input:
    416				     ;	     di=address	of string (s)
    417				     ;	     dx=index (i) of first char	to delete
    418				     ;	     cx=number of chars	to delete (n)
    419				     ;
    420				     ;Output:
    421				     ;	     n characters deleted from string at s[i]
    422				     ;	     Note: prevents deleting past end of string
    423				     ;
    424				     ;Registers:
    425				     ;	     none
    426				     ;
    427				     ;--------------------------------------------------------
    428	010C			     StrDelete	      proc	      near
    429
    430	010C  53			      push   bx	     ; save modified registers
    431	010D  51			      push   cx
    432	010E  57			      push   di
    433	010F  56			      push   si
    434				     ;
    435				     ; bx = SourceIndex
    436				     ; cx = count / len	/ chars	to move
    437				     ; dx = Index
    438	0110  8B DA			     mov     bx,dx   ; assign string index to bx
    439	0112  03 D9			     add     bx,cx   ; source index <-index+count
    440	0114  E8 FFB6			     call    StrLength	     ; cx <- length(s)
    441	0117  3B CB			     cmp     cx,bx   ; is length >index
    442	0119  77 08			     ja	     @@12    ; if yes jump to delete chars
    443	011B  03 FA			     add     di,dx   ; else calcualte index to string end
    444	011D  C6 05 00			     mov     byte ptr[di], ASCNull   ; and inset null
    445	0120  EB 09 90			     jmp     @@96    ; jump to exit
    446	0123			     @@12:
    447	0123  8B F7			     mov     si,di   ; make source = destination
    448	0125  2B CB			     sub     cx,bx   ; Chars to	move <-	len - source index
    449	0127  41			     inc     cx	     ; plus one	for null at end	of the string
    450	0128  E8 FF78			     call    MoveLeft	     ; move chars over deleted portion
    451
    452	012B			     @@96:
    453	012B  5E			     pop     si
    454	012C  5F			     pop     di	     ; restore registers
    455	012D  59			     pop     cx
    456	012E  5B			     pop     bx
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 9
c:STRINGS.asm



    457	012F  C3			     ret     ; return to calling program
    458	0130			     StrDelete	    endp
    459
    460				     ;------------------------------------------------------
    461				     ; StrInsert procedure
    462				     ;
    463				     ;Input:
    464				     ;	     si=address	of source string (s1)
    465				     ;	     di=address	of destination string (s2)
    466				     ;	     note: s2 must be large enough to expand by	length (s1)!
    467				     ;
    468				     ;Output:
    469				     ;	     chars from	s1 inserted at s2[i]
    470				     ;	     s1	not changed
    471				     ;
    472				     ;Registers:
    473				     ;	     none
    474				     ;
    475				     ;--------------------------------------------------------
    476	0130			     StrInsert	      proc	      near
    477
    478	0130  50			      push   ax	     ; save modified registers
    479	0131  53			      push   bx
    480	0132  51			      push   cx
    481				     ;
    482				     ; ax = LenInsertion
    483				     ; cx = chars to move
    484				     ;
    485	0133  87 F7			     xchg    si,di   ; exchange	si and di
    486	0135  E8 FF95			     call    StrLength	     ; find length of si
    487	0138  87 F7			     xchg    si,di   ; restore si and di
    488	013A  8B C1			     mov     ax,cx   ; save length in ax
    489	013C  E8 FF8E			     call    StrLength	     ; find length of s2
    490	013F  2B CA			     sub     cx,dx   ; cx <- length(s2)-1+i
    491	0141  41			     inc     cx	     ; cx = chars to move
    492				     ;
    493				     ; bx = s1 index
    494				     ;
    495	0142  52			     push    dx	     ; save index (dx) and si
    496	0143  56			     push    si
    497	0144  8B F7			     mov     si,di   ; make si and di address s2
    498	0146  8B DA			     mov     bx,dx   ;set s1 index to dx (i)
    499	0148  03 D0			     add     dx,ax   ; set s2 index to 1+lenInsertion
    500	014A  E8 FF66			     call    MoveRight ; open a	hole for the insertion
    501	014D  5E			     pop     si	     ; restore index (dx) and si
    502	014E  5A			     pop     dx
    503
    504	014F  33 DB			     xor     bx,bx   ; set s1 index to 0
    505	0151  8B C8			     mov     cx,ax   ; set cx to lenInsertion
    506	0153  E8 FF4D			     call    MoveLeft	     ; insert s1 into hole in s2
    507
    508	0156  59			     pop     cx
    509	0157  5B			     pop     bx	     ; restore registers
    510	0158  58			     pop     ax
    511	0159  C3			     ret     ; return to calling program
    512	015A			     StrInsert	    endp
    513
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 10
c:STRINGS.asm



    514
    515
    516				     ;------------------------------------------------------
    517				     ; StrConcat procedure
    518				     ;
    519				     ;Input:
    520				     ;	     si=address	of source string (s1)
    521				     ;	     di=address	of destination string (s2)
    522				     ;	     note: s2 must be large enough to expand by	length (s1)!
    523				     ;
    524				     ;Output:
    525				     ;	     chars from	s1 added to end	of s2
    526				     ;
    527				     ;Registers:
    528				     ;	     none
    529				     ;
    530				     ;--------------------------------------------------------
    531	015A			     StrConcat	      proc	      near
    532
    533	015A  53			      push   bx	     ; save modified registers
    534	015B  51			      push   cx
    535	015C  52			      push   dx
    536				     ;
    537				     ; dx = s2 destination
    538				     ;
    539	015D  E8 FF6D			     call    StrLength	     ; cx <- length(s2)
    540	0160  8B D1			     mov     dx,cx	     ; set dx to index end of string
    541	0162  87 F7			     xchg    si,di	     ; exchange	si and di
    542	0164  E8 FF66			     call    StrLength	     ; find the	length of s1
    543	0167  41			     inc     cx		     ; plus 1 includes null terminator
    544	0168  87 F7			     xchg    si,di	     ; restore si and di
    545	016A  33 DB			     xor     bx,bx	     ; source index =0
    546	016C  E8 FF34			     call    MoveLeft	     ; copy source string to destination
    547
    548	016F  5A			     pop     dx
    549	0170  59			     pop     cx	     ; restore registers
    550	0171  5B			     pop     bx
    551	0172  C3			     ret     ; return to calling program
    552	0173			     StrConcat	    endp
    553
    554				     ;------------------------------------------------------
    555				     ; StrCopy procedure
    556				     ;
    557				     ;Input:
    558				     ;	     si=address	of source string (s1)
    559				     ;	     di=address	of destination string (s2)
    560				     ;
    561				     ;Output:
    562				     ;	     chars in s1 copied	to s2
    563				     ;	     NOTE: s2 must be at least length(s1) + 1 byte long
    564				     ;
    565				     ;Registers:
    566				     ;	     none
    567				     ;
    568				     ;--------------------------------------------------------
    569	0173			     StrCopy	    proc	    near
    570
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 11
c:STRINGS.asm



    571	0173  53			      push   bx	     ; save modified registers
    572	0174  51			      push   cx
    573	0175  52			      push   dx
    574
    575	0176  87 F7			     xchg    si,di	     ; swap si and di
    576	0178  E8 FF52			     call    StrLength	     ; cx <- length(s1)
    577	017B  41			     inc     cx		     ; plus 1 includes null terminator
    578	017C  87 F7			     xchg    si,di	     ; restore si and di
    579	017E  33 DB			     xor     bx,bx	     ; source string index =0
    580	0180  33 D2			     xor     dx,dx	     ; destination string index	= 0
    581	0182  E8 FF1E			     call    MoveLeft	     ; copy source to destination
    582
    583	0185  5A			     pop     dx
    584	0186  59			     pop     cx	     ; restore registers
    585	0187  5B			     pop     bx
    586	0188  C3			     ret     ; return to calling program
    587	0189			     StrCopy	  endp
    588
    589				     ;------------------------------------------------------
    590				     ; StrPos procedure
    591				     ;
    592				     ;Input:
    593				     ;	     si=address	of substring to	find
    594				     ;	     di=address	of target string to scan
    595				     ;
    596				     ;Output:
    597				     ;	     if	zf = 1 the dx=index of substring
    598				     ;	     if	zf = 0 then substring was not found
    599				     ;	     NOTE: dx is meaningless if	zf=0
    600				     ;
    601				     ;Registers:
    602				     ;	     none
    603				     ;
    604				     ;--------------------------------------------------------
    605	0189			     StrPos	   proc		   near
    606
    607	0189  50			      push   ax	     ; save modified registers
    608	018A  53			      push   bx
    609	018B  51			      push   cx
    610	018C  57			      push   di
    611
    612	018D  E8 FF3D			     call    StrLength	     ; find length of target string
    613	0190  8B C1			     mov     ax,cx	     ; save length (s2)	in ax
    614	0192  87 F7			     xchg    si,di	     ; swap si and di
    615	0194  E8 FF36			     call    StrLength	     ; find length of substring
    616	0197  8B D9			     mov     bx,cx	     ; save length (s1)	in bx
    617	0199  87 F7			     xchg    si,di	     ; restore si and di
    618	019B  2B C3			     sub     ax,bx	     ; ax = last possible index
    619	019D  72 18			     jb	     @@22	     ; exit if len target < len	substring
    620	019F  BA FFFF			     mov     dx,0ffffh	     ; initialize dx to	-1
    621
    622	01A2			     @@13:
    623	01A2  42			     inc     dx		     ; for i=0 to last possible	index
    624	01A3  8A 09			     mov     cl, byte ptr[bx+di]     ; save char at s[bx] in cl
    625	01A5  C6 01 00			     mov     byte ptr[bx+di],ASCNull ; replace char with null
    626	01A8  E8 FF51			     call    StrCompare	     ; compare si to altered di
    627	01AB  88 09			     mov     byte ptr[bx+di],cl	     ; restore replaced	char
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 12
c:STRINGS.asm



    628	01AD  74 08			     je	     @@22	     ;jump if match found, dx =	index, zf =1
    629	01AF  47			     inc     di		     ; else advance target string index
    630	01B0  3B D0			     cmp     dx,ax	     ; when equal, all positions checked
    631	01B2  75 EE			     jne     @@13	     ; continue	search unless not found
    632
    633	01B4  33 C9			     xor     cx,cx	     ; substring not found reset zf=0
    634	01B6  41			     inc     cx		     ; to indicate no match
    635
    636	01B7			     @@22:
    637	01B7  5F			     pop     di
    638	01B8  59			     pop     cx	     ; restore registers
    639	01B9  5B			     pop     bx
    640	01BA  58			     pop     ax
    641	01BB  C3			     ret     ; return to calling program
    642	01BC			     StrPos	 endp
    643
    644				     ;------------------------------------------------------
    645				     ; StrRemove procedure
    646				     ;
    647				     ;Input:
    648				     ;	     si=address	of substring to	delete
    649				     ;	     di=address	of target string to delete substring from
    650				     ;
    651				     ;Output:
    652				     ;	     if	zf = 1 then substring removed
    653				     ;	     if	zf = 0 then substring was not found
    654				     ;	     NOTE: string at si	is not changed
    655				     ;	     NOTE: if zf=0 then	string at di is	not changed
    656				     ;
    657				     ;Registers:
    658				     ;	     none
    659				     ;
    660				     ;--------------------------------------------------------
    661	01BC			     StrRemove	      proc	      near
    662
    663	01BC  51			      push   cx	     ; save modified registers
    664	01BD  52			      push   dx
    665
    666	01BE  E8 FFC8			      call   StrPos  ; find sunstring, setting dx=index
    667	01C1  75 0C			      jne    @@95    ; exit if substring not found
    668	01C3  9C			      pushf	     ; save zf flag
    669
    670	01C4  87 F7			      xchg   si,di   ; swap si and di
    671	01C6  E8 FF04			      call   StrLength	     ; find length of substring
    672	01C9  87 F7			      xchg   si,di	     ; restore si and di
    673	01CB  E8 FF3E			      call   StrDelete	     ; delete cx chars at di[dx]
    674	01CE  9D			      popf		     ; restore zf flag
    675
    676	01CF			     @@95:
    677	01CF  5A			     pop     dx
    678	01D0  59			     pop     cx	     ; restore registers
    679	01D1  C3			     ret     ; return to calling program
    680	01D2			     StrRemove	    endp
    681
    682				     ;------------------------------------------------------
    683				     ; StrRead procedure
    684				     ;
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 13
c:STRINGS.asm



    685				     ;Input:
    686				     ;	     di=address	of destination string
    687				     ;	     cl=maximum	string length EXCLUDING	null terminator
    688				     ;	     NOTE: if cl=0, StrRead does nothing
    689				     ;	     NOTE: actual variable must	be cl+1	btes long
    690				     ;	     NOTE: string length is limited to 255 characters
    691				     ;
    692				     ;Output:
    693				     ;	     string copied from	standard input into your buffer
    694				     ;
    695				     ;Registers:
    696				     ;	     none
    697				     ;
    698				     ;--------------------------------------------------------
    699	01D2			     StrRead	    proc	    near
    700
    701	01D2  0A C9			    or	     cl,cl   ; is cl=0?
    702	01D4  74 20			    jz	     @@80    ; if yes, jump to exit
    703
    704	01D6  50			    push   ax	   ; save modified registers
    705	01D7  53			    push   bx
    706	01D8  52			    push   dx
    707	01D9  56			    push   si
    708
    709	01DA  88 0E 02BAr		    mov	   [buffer.maxLen],cl	     ; set max len byte
    710	01DE  B4 0A			    mov	   ah,0ah		     ; DOS buffered input function
    711	01E0  BA 02BAr			    mov	   dx, offset buffer.maxLen  ; address struc with ds:dx
    712	01E3  CD 21			    int	   21h			     ; call DOs	to read	string
    713
    714	01E5  32 FF			    xor	   bh,bh     ; zero high byte of bx
    715	01E7  8A 1E 02BBr		    mov	   bl,[buffer.strLen]	     ; bx = # chars in buffer
    716	01EB  C6 87 02BCr 00		    mov	   [bx+buffer.chars], ASCNull	     ; change cr to null
    717	01F0  BE 02BCr			    mov	   si, offset buffer.chars   ; address buffer with si
    718	01F3  E8 FF7D			    call   StrCopy		     ; copy chars to user string
    719
    720	01F6			     @@80:
    721	01F6  5E			     pop     si
    722	01F7  5A			     pop     dx	     ; restore registers
    723	01F8  5B			     pop     bx
    724	01F9  58			     pop     ax
    725
    726	01FA  C3			     ret     ; return to calling program
    727	01FB			     StrRead	  endp
    728
    729				     ;------------------------------------------------------
    730				     ; StrWrite/Strwrite2 procedure
    731				     ;
    732				     ;Input:
    733				     ;	     di=address	of  string (s)
    734				     ;	     cx=number of chars	to write (StrWrite2 only)
    735				     ;
    736				     ;Output:
    737				     ;	     string a copied to	standard output
    738				     ;
    739				     ;Registers:
    740				     ;	     cx	(StrWrite only)
    741				     ;
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 14
c:STRINGS.asm



    742				     ;--------------------------------------------------------
    743	01FB			     StrWrite	    proc	    near
    744
    745	01FB  E8 FECF			    call     StrLength ; set cx=length of string
    746
    747
    748	01FE  50			    push   ax	   ; save modified registers
    749	01FF  53			    push   bx
    750	0200  52			    push   dx
    751
    752	0201  BB 0001			    mov	   bx,1	     ; standard	output handle
    753	0204  8B D7			    mov	   dx,di     ; ds:dx address string
    754	0206  B4 40			    mov	   ah,40h    ; DOS write to file or device
    755	0208  CD 21			    int	   21h	     ; call DOS	on return ax = # char written
    756
    757	020A  5A			    pop	    dx	    ; restore registers
    758	020B  5B			    pop	    bx
    759	020C  58			    pop	    ax
    760
    761	020D  C3			     ret     ; return to calling program
    762	020E			     StrWrite	     endp
    763
    764
    765				     ;------------------------------------------------------
    766				     ; NewLine procedure
    767				     ;
    768				     ;Input:
    769				     ;	     none
    770				     ;
    771				     ;Output:
    772				     ;	     carriage return, line feed	sent to	standard output
    773				     ;
    774				     ;Registers:
    775				     ;	     ah, dl
    776				     ;
    777				     ;--------------------------------------------------------
    778	020E			     NewLine	   proc		   near
    779
    780	020E  B4 02			   mov	 ah,2	     ;DOS write	char routine
    781	0210  B2 0D			   mov	 dl,ASCcr    ; load carriage return into dl
    782	0212  CD 21			   int	 21h	     ; write carriage return
    783
    784	0214  B4 02			   mov	 ah,2	     ;DOS write	char routine
    785	0216  B2 0A			   mov	 dl,ASClf    ; load line feed into dl
    786	0218  CD 21			   int	 21h	     ; write carriage return
    787
    788	021A  C3			     ret     ; return to calling program
    789	021B			     NewLine	  endp
    790
    791				     END   ProgramStart
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 15
Symbol Table




Symbol Name		Type   Value			   Cref	(defined at #)

??date			Text   "04/26/20"
??filename		Text   "STRINGS	"
??time			Text   "04:08:50"
??version		Number 030A
@32Bit			Text   0			   #2
@@10			Near   STRINGS_TEXT:00E9	   #354	 364
@@11			Near   STRINGS_TEXT:0100	   #397	 402
@@12			Near   STRINGS_TEXT:0123	   442	#446
@@13			Near   STRINGS_TEXT:01A2	   #622	 631
@@20			Near   STRINGS_TEXT:00F4	   357	359  #362
@@21			Near   STRINGS_TEXT:0108	   400	#404
@@22			Near   STRINGS_TEXT:01B7	   619	628  #636
@@80			Near   STRINGS_TEXT:01F6	   702	#720
@@95			Near   STRINGS_TEXT:01CF	   667	#676
@@96			Near   STRINGS_TEXT:012B	   445	#452
@@97			Near   STRINGS_TEXT:00F7	   349	#366
@@98			Near   STRINGS_TEXT:00C8	   251	#270
@@99			Near   STRINGS_TEXT:00B2	   214	#228
@CodeSize		Text   1			   #2
@Cpu			Text   0101H
@DataSize		Text   1			   #2
@FileName		Text   STRINGS
@Interface		Text   00h			   #2
@Model			Text   5			   #2
@WordSize		Text   2			   #7  #117
@code			Text   STRINGS_TEXT		   #2  #2  #117
@curseg			Text   STRINGS_TEXT		   #7  #117
@data			Text   DGROUP			   #2  119
@stack			Text   DGROUP			   #2
ASCNull			Number 0000			   #8  289  444	 625  716
ASCcr			Number 000D			   #9  15  19  781
ASClf			Number 000A			   #10	15  19	19  785
BuffSize		Number 00FF			   #11	93  95
MaxL			Number 0080			   #12	24  127
MoveLeft		Near   STRINGS_TEXT:00A3	   137	#212  450  506	546  581
MoveRight		Near   STRINGS_TEXT:00B3	   #249	 500
NewLine			Near   STRINGS_TEXT:020E	   129	150  179  183  #778
ProgramStart		Near   STRINGS_TEXT:0000	   #118	 791
StrCompare		Near   STRINGS_TEXT:00FC	   #389	 626
StrConcat		Near   STRINGS_TEXT:015A	   167	#531
StrCopy			Near   STRINGS_TEXT:0173	   171	#569  718
StrDelete		Near   STRINGS_TEXT:010C	   158	#428  673
StrInsert		Near   STRINGS_TEXT:0130	   163	#476
StrLength		Near   STRINGS_TEXT:00CD	   143	#308  348  440	486  489  539  542  576	 612  615  671	745
StrNull			Near   STRINGS_TEXT:00C9	   140	#287
StrPos			Near   STRINGS_TEXT:0189	   175	#605  666
StrRead			Near   STRINGS_TEXT:01D2	   128	#699
StrRemove		Near   STRINGS_TEXT:01BC	   189	#661
StrUpper		Near   STRINGS_TEXT:00DD	   153	#341
StrWrite		Near   STRINGS_TEXT:01FB	   124	130  #743
areaCode		Byte   DGROUP:02B3		   #87	187
buff			Byte   DGROUP:00FA		   #31	139
buffer			Struct DGROUP:02BA StrBuffer	   #98	709  711  715  716  717
dest			Byte   DGROUP:01B5		   #52	161
Turbo Assembler	 Version 3.1	    04/26/20 04:08:51	    Page 16
Symbol Table



dest1			Byte   DGROUP:020F		   #66	166
eureka			Byte   DGROUP:0297		   #81	181
exCode			Byte   DGROUP:0000		   #14
ext			Byte   DGROUP:0287		   #78	173
fdext			Near   STRINGS_TEXT:0089	   176	#179
filename		Byte   DGROUP:028C		   #79	174
lbl1			Near   STRINGS_TEXT:0041	   145	#147
lbl2			Near   STRINGS_TEXT:004B	   146	#151
lc			Byte   DGROUP:0178		   #41	152
notfdext		Near   STRINGS_TEXT:0096	   177	#186
phoneNumber		Byte   DGROUP:02A4		   #84	188
source			Byte   DGROUP:01FF		   #62	160
source1			Byte   DGROUP:0206		   #64	165
str1			Byte   DGROUP:014B		   #33	142
str2			Byte   DGROUP:0167		   #37	148
str3			Byte   DGROUP:0192		   #46	155
str4			Byte   DGROUP:0227		   #73	169
str5			Byte   DGROUP:0237		   #76	170
testString		Byte   DGROUP:003C		   #24	126
v1			Byte   DGROUP:00BD		   #26	132
v2			Byte   DGROUP:00D2		   #29	133
welcome			Byte   DGROUP:0001		   #15	123

Structure Name		Type  Offset			   Cref	(defined at #)

StrBuffer						   #92	98
 maxLen			Byte   0000
 strLen			Byte   0001
 chars			Byte   0002

Groups & Segments	Bit Size Align	Combine	Class	   Cref	(defined at #)

DGROUP			Group				   #2  2  119
  STACK			16  0200 Para	Stack	STACK	   #4
  _DATA			16  03BB Word	Public	DATA	   #2  #7
STRINGS_TEXT		16  021B Word	Public	CODE	   #2  2  #117	117
